import os
import re
import pandas as pd

class SequenceFrame( pd.DataFrame ):
    """
    The :py:class:`.SequenceFrame` extends :py:class:`pandas.DataFrame`.
    Ideally, in this DataFrame, each column represents a ResidueType (or
    NucleotideType) and each row a sequence position.
    A reference sequence can be provided, but it has to be the exact same
    length as the sequence expressed in the DataFrame.
    As it represents sequence, unless the SequenceFrame is generated by
    slicing another, one should expect the index to start in 1.
    """
    _metadata = ['_reference_sequence', '_reference_shift', '_measure', '_extras', '_delextra', '_delempty']

    def __init__(self, *args, **kw):
        super(SequenceFrame, self).__init__(*args, **kw)
        self._reference_sequence = ""
        self._reference_shift    = 1
        self._measure  = ""
        self._extras   = []
        self._delextra = True
        self._delempty = False

    def reference_sequence( self, sequence=None, shift=1 ):
        """
        Setter/Getter for a reference sequence. It also allows to provide
        the shift of the sequence count with respect to a linear numbering
        (Rosetta numbering).

        :param str sequence: Reference sequence. By default is
            :py:data:`None`, which turns the function into a getter.
        :param int shift: In case the sequence does not start in 1, how much
            do we need to shift? Basically provide the number of the first
            residue of the chain. Default is 1.
        :return: str
        """
        if sequence is not None:
            self._reference_sequence = sequence
            self._reference_shift    = shift

        return self._reference_sequence

    def reference_shift( self, shift=None ):
        """
        Setter/Getter for a reference shift.

        :param int shift: In case the sequence does not start in 1, how much
            do we need to shift? Basically provide the number of the first
            residue of the chain. By default is :py:data:`None`, which turns
            the function into a getter.
        :return: int
        """

        if shift not is None:
            self._reference_shift = shift
        return self._reference_shift

    def extras( self, extras=None ):
        """
        Setter/Getter for the extra amino/nucleic acid names.
        Defines those names that are not regular/natural monomers.
        :param list measure: List of 1 letter names to be considered. By default is
            :py:data:`None`, which turns the function into a getter.
        """
        if extras is not None:
            self._extras = extras
        return self._extras

    def delete_extra( self, pick=None ):
        """
        Setter/Getter for the delete extra configuration.
        Set the behaviour to decide whether or not non-regular positions
        have to be deleted if empty.
        :param bool pick: Whether or not to activate this option. By default is
            :py:data:`None`, which turns the function into a getter.
        """
        if pick is not None:
            self._delextra = pick
        return self._delextra

    def delete_empty( self, pick=None ):
        """
        Setter/Getter for the delete empty configuration.
        Set the behaviour to decide whether or not regular positions
        have to be deleted if empty.
        :param bool pick: Whether or not to activate this option. By default is
            :py:data:`None`, which turns the function into a getter.
        """
        if pick is not None:
            self._delempty = pick
        return self._delempty

    def measure( self, measure=None ):
        """
        Setter/Getter for the mesurement specification.
        Specifies which type of mesurement the object represents.
        It can be 'frequency' or 'bits'.
        :param str measure: Measure name. By default is
            :py:data:`None`, which turns the function into a getter.
        """
        known = ["frequency", "bits"]
        if measure is not None:
            if measure.lower() not in known:
                raise ValueError("Measure type {0} not in {1}".format(measure, ",".join(known)))
            self._measure = measure
        return self._measure

    def has_reference_sequence( self ):
        """
        Checks if there is a reference sequence.
        :param str seqID: Identifier of the reference sequence
        :return: bool
        """
        return self._reference_sequence != ""

    def clean( self ):
        """
        Apply the logic set by clean_extra and clean_empty.
        :return: The properly filtered :py:class:`.SequenceFrame`
        """
        pass

    def select_key_sequence_positions( self, selector ):
        """
        By providing a list of key positions to keep, the
        SequenceFrame is filtered so that only those positions
        are kept
        :param list selector: List of integers of the positions
            of interest.
        :return: :py:class:`.SequenceFrame`
        """
        pass

    @property
    def _constructor( self ):
        return SequenceFrame
