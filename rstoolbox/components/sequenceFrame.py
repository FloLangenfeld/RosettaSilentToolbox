# @Author: Jaume Bonet <bonet>
# @Date:   09-Nov-2017
# @Email:  jaume.bonet@gmail.com
# @Filename: sequenceFrame.py
# @Last modified by:   bonet
# @Last modified time: 12-Mar-2018

# Standard Libraries
import os
import re

# External Libraries
import pandas as pd
import numpy as np

# This Library
from .rsbase import RSBaseFrequency


class SequenceFrame( pd.DataFrame ):
    """
    The :py:class:`.SequenceFrame` extends :py:class:`pandas.DataFrame`.
    Ideally, in this DataFrame, each column represents a ResidueType (or
    NucleotideType) and each row a sequence position.
    A reference sequence can be provided, but it has to be the exact same
    length as the sequence expressed in the DataFrame.
    As it represents sequence, unless the SequenceFrame is generated by
    slicing another, one should expect the index to start in 1.
    """
    _metadata = ['_reference_sequence', '_reference_shift', '_measure', '_extras', '_delextra', '_delempty']

    def __init__(self, *args, **kw):
        super(SequenceFrame, self).__init__(*args, **kw)
        self._reference_sequence = ""
        self._reference_shift    = 1
        self._measure    = ""
        self._extras     = []
        self._delextra   = True
        self._delempty   = -1

    def reference_sequence( self, sequence=None, shift=1 ):
        """
        Setter/Getter for a reference sequence. It also allows to provide
        the shift of the sequence count with respect to a linear numbering
        (Rosetta numbering).

        :param str sequence: Reference sequence. By default is
            :py:data:`None`, which turns the function into a getter.
        :param int shift: In case the sequence does not start in 1, how much
            do we need to shift? Basically provide the number of the first
            residue of the chain. Default is 1.
        :return: str
        """
        if sequence is not None:
            self._reference_sequence = sequence
            self._reference_shift    = shift

        return self._reference_sequence

    def reference_shift( self, shift=None ):
        """
        Setter/Getter for a reference shift.

        :param int shift: In case the sequence does not start in 1, how much
            do we need to shift? Basically provide the number of the first
            residue of the chain. By default is :py:data:`None`, which turns
            the function into a getter.
        :return: int
        """
        if shift is not None:
            self._reference_shift = shift
        return self._reference_shift

    def key_reference_sequence( self, key_residues, check=True ):
        """
        Select the provided list of key_residues according to the
        reference_shift.
        :param list key_residues: List of residues to retrieve (numbering takes shift)
            into account.
        :param bool check: If True (default), will rise error if there is no reference sequence.
        :return: str
        :raises: ValueError if  there is no reference sequence and check is True.
        """
        if self._reference_sequence == "" and check:
            raise ValueError("Requested key residues of an unespecified reference sequence")
        if key_residues is None:
            return self._reference_sequence
        if self._reference_sequence == "":
            return self._reference_sequence
        kr = np.array(key_residues) - self._reference_shift
        return "".join([x for i, x in enumerate(self._reference_sequence) if i in kr])

    def extras( self, extras=None ):
        """
        Setter/Getter for the extra amino/nucleic acid names.
        Defines those names that are not regular/natural monomers.
        :param list measure: List of 1 letter names to be considered. By default is
            :py:data:`None`, which turns the function into a getter.
        :return: list
        """
        if extras is not None:
            self._extras = extras
        return self._extras

    def delete_extra( self, pick=None ):
        """
        Setter/Getter for the delete extra configuration.
        Set the behaviour to decide whether or not non-regular positions
        have to be deleted if empty.
        :param bool pick: Whether or not to activate this option. By default is
            :py:data:`None`, which turns the function into a getter.
        :return: bool
        """
        if pick is not None:
            self._delextra = pick
        return self._delextra

    def delete_empty( self, pick=None ):
        """
        Setter/Getter for the delete empty configuration.
        Set the behaviour to decide whether or not regular positions
        have to be deleted if empty. This does not apply to amino acid types
        present in the reference_sequence.
        :param int pick: Remove from the SequenceFrame the regular
            amino/nucleic acids if they frequency is equal or under the value . Default is -1,
            so nothing is deleted.
        :return: bool
        """
        if pick is not None:
            self._delempty = pick
        return self._delempty

    def is_transposed( self ):
        """
        :py:class:`.SequenceFrame`, when created, has each column specify a residue type
        and each row specify a sequence position. When it is the other way around, we assume
        it is transposed.
        :return: True if the object is transposed.
        """
        h = list(self)[0]
        if isinstance(h, basestring):
            return False
        else:
            return True

    def measure( self, measure=None ):
        """
        Setter/Getter for the mesurement specification.
        Specifies which type of mesurement the object represents.
        It can be 'frequency' or 'bits'.
        :param str measure: Measure name. By default is
            :py:data:`None`, which turns the function into a getter.
        """
        known = ["frequency", "bits"]
        if measure is not None:
            if measure.lower() not in known:
                raise ValueError("Measure type {0} not in {1}".format(measure, ",".join(known)))
            self._measure = measure
        return self._measure

    def has_reference_sequence( self ):
        """
        Checks if there is a reference sequence.
        :param str seqID: Identifier of the reference sequence
        :return: bool
        """
        return self._reference_sequence != ""

    def max_hight( self ):
        """
        Calculate the maximum expected value considering the amount of variants.
        If :py:class:`.SequenceFrame` is of type "frequency", it will return 1.

        For type "bits", this is calculated as:
            log2 N
        Where:
            - N is the total number of options (4: DNA/RNA; 20: PROTEIN). This is automatically
              picked from the number of columns, which means that adding/deleting columns for
              different reasons will translate into different maximum expected height.

        :return: float
        """
        if self.measure() == "frequency":
            return 1
        elif self.measure() == "bits":
            return np.log2(self.shape[1])

    def to_bits( self ):
        """
        Change the sequenceFrame from frequency to bits.
        Bit calculation is performed as explained in http://www.genome.org/cgi/doi/10.1101/gr.849004

        Rseq = Smax - Sobs = log2 N - (-sum(n=1,N):pn * log2 pn)

        Where:
            - N is the total number of options (4: DNA/RNA; 20: PROTEIN). This is automatically
              picked from the number of columns, which means that adding/deleting columns for
              different reasons will translate into different maximum expected height.
            - pn is the observed frequency of the symbol n.

        :return: a new :py:class:`.SequenceFrame`
        """
        def get_position_height( row ):
            def individual_entropy( cell ):
                return np.log2(cell) * cell
            return np.sum(row.apply(lambda cell: individual_entropy(cell)))

        if self.measure() == "bits":
            return self

        df = self.copy(deep=True)
        df.measure("bits")
        df["entropy"] = df.max_hight() + df.apply(lambda row: get_position_height( row ), axis=1)
        aa_columns = [col for col in df.columns if len(col)==1]
        return df[aa_columns].multiply(df["entropy"], axis=0)

    def clean( self ):
        """
        Apply the logic set by clean_extra and clean_empty.
        Modifications are applied "inplace"
        :return: self
        """
        if self.is_transposed():
            return self.transpose().clean().transpose()

        if set(self.extras()).issubset(self.columns):
            if self.delete_extra():
                self.drop(self.extras(), axis=1, inplace=True)

        if self.delete_empty() >= 0:
            s = pd.Series((self <= self.delete_empty()).sum(axis=0) == self.shape[0])
            todel = s[s==True].index.tolist()
            if self._reference_sequence != "":
                todel = set(todel).difference(set(list(self._reference_sequence)))
            self.drop(todel, axis=1, inplace=True)
        return self

    #
    # Implement pandas methods
    #

    @property
    def _constructor( self ):
        return SequenceFrame
